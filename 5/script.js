//1
// function F(titleOfTag , action , attr) {
//     this.titleOfTag = titleOfTag;
//     this.action = action;
//     this.arr = attr;
//
// }
// let a = new F('a' ,'Тег  является одним из важных элементов HTML и предназначен для создания ссылок. В зависимости от присутствия атрибутов name или href тег  устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы. ' ,[{accesskey:'Активация ссылки с помощью комбинации клавиш. '},{coords:'Устанавливает координаты активной области.'}]);
// let div = new F('div' ,'Элемент  является блочным элементом и предназначен для выделения фрагмента документа с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора. ' ,[{align:'Задает выравнивание содержимого тега div.'},{title:'Добавляет всплывающую подсказку к содержимому. '}]);
// let h1 = new F('h1' ,'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег h1 представляет собой наиболее важный заголовок первого уровня, а тег h6 служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги h1,...,h6 относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.  ' ,[{align:'Определяет выравнивание заголовка. '},{margin:'Задає відступи. '}]);
// let span = new F('span' ,'Тег span предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как table, p или div, с помощью тега span можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега p) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег span и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.  ' ,[{pading:'Задає відступи в середині елементу. '},{margin:'Задає відступи за елементом. '}]);
// let input = new F('input' ,'Тег input является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом input предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент input не требуется помещать внутрь контейнера form, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать form обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript. ' ,[{accept:'Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов. '},{accesskey:'Переход к элементу с помощью комбинации клавиш.  '}]);
// let form = new F('form' ,' Тег form устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению.Документ может содержать любое количество форм, но одновременно на сервер может быть отправлена только одна форма. По этой причине данные форм должны быть независимы друг от друга.Для отправки формы на сервер используется кнопка Submit, того же можно добиться, если нажать клавишу Enter в пределах формы. Если кнопка Submit отсутствует в форме, клавиша Enter имитирует ее использование. ' ,[{action:' Адрес программы или документа, который обрабатывает данные формы.  '},{autocomplete:'Включает автозаполнение полей формы. '}]);
// let option = new F('option' ,'  Тег option определяет отдельные пункты списка, создаваемого с помощью контейнера select. Ширина списка определяется самым широким текстом, указанным в теге option, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент select внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты. ' ,[{disabled:'Заблокировать для доступа элемент списка.'},{label:'Указание метки пункта списка.'}]);
// let select = new F('select' ,'Тег select позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега select, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге option, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега option, который должен быть вложен в контейнер select. Если планируется отправлять данные списка на сервер, то требуется поместить элемент select внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.  ' ,[{accesskey:'    Позволяет перейти к списку с помощью некоторого сочетания клавиш.'},{autofocus:'Устанавливает, что список получает фокус после загрузки страницы.'}]);
//
// console.log(a);

//2
// class F{
//     constructor(titleOfTag , action , attr) {
//         this.titleOfTag = titleOfTag;
//         this.action = action;
//         this.arr = attr;
//     }
// }
// let a = new F('a' ,'Тег  является одним из важных элементов HTML и предназначен для создания ссылок. В зависимости от присутствия атрибутов name или href тег  устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке внутри веб-страницы. ' ,[{accesskey:'Активация ссылки с помощью комбинации клавиш. '},{coords:'Устанавливает координаты активной области.'}]);
// let div = new F('div' ,'Элемент  является блочным элементом и предназначен для выделения фрагмента документа с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора. ' ,[{align:'Задает выравнивание содержимого тега div.'},{title:'Добавляет всплывающую подсказку к содержимому. '}]);
// let h1 = new F('h1' ,'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег h1 представляет собой наиболее важный заголовок первого уровня, а тег h6 служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги h1,...,h6 относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.  ' ,[{align:'Определяет выравнивание заголовка. '},{margin:'Задає відступи. '}]);
// let span = new F('span' ,'Тег span предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как table, p или div, с помощью тега span можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега p) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег span и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.  ' ,[{pading:'Задає відступи в середині елементу. '},{margin:'Задає відступи за елементом. '}]);
// let input = new F('input' ,'Тег input является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом input предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент input не требуется помещать внутрь контейнера form, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать form обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript. ' ,[{accept:'Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов. '},{accesskey:'Переход к элементу с помощью комбинации клавиш.  '}]);
// let form = new F('form' ,' Тег form устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению.Документ может содержать любое количество форм, но одновременно на сервер может быть отправлена только одна форма. По этой причине данные форм должны быть независимы друг от друга.Для отправки формы на сервер используется кнопка Submit, того же можно добиться, если нажать клавишу Enter в пределах формы. Если кнопка Submit отсутствует в форме, клавиша Enter имитирует ее использование. ' ,[{action:' Адрес программы или документа, который обрабатывает данные формы.  '},{autocomplete:'Включает автозаполнение полей формы. '}]);
// let option = new F('option' ,'  Тег option определяет отдельные пункты списка, создаваемого с помощью контейнера select. Ширина списка определяется самым широким текстом, указанным в теге option, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент select внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты. ' ,[{disabled:'Заблокировать для доступа элемент списка.'},{label:'Указание метки пункта списка.'}]);
// let select = new F('select' ,'Тег select позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега select, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге option, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега option, который должен быть вложен в контейнер select. Если планируется отправлять данные списка на сервер, то требуется поместить элемент select внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.  ' ,[{accesskey:'    Позволяет перейти к списку с помощью некоторого сочетания клавиш.'},{autofocus:'Устанавливает, что список получает фокус после загрузки страницы.'}]);
//
// console.log(div);

//3
// let car ={
//     model:'Lada Kalina',
//     producer:'MAЗ',
//     age :2017,
//     speed:187,
//     engine:'90sm^3',
//     newSpeed : 190,
//     newValue: 2019,
//
//     MaxSpeed:function (){
//     car.speed = car.newSpeed
// },
//     changeYear:function (){
//     car.age = car.newValue
// },
//     addDriver:function (){
//     car.driver={name:'Ivan' , age:23 }
// },
//     info:function (){
//     console.log(car)
// },
//     drive:function (){
//     console.log(`Їдемо зі швидкістю ${car.speed}`)
// }
//
//
//
// }
// car.MaxSpeed()
// car.changeYear()
// car.addDriver()
// car.drive()
// car.info()


//4
// function F (model, producer, age , speed,  engine , newSpeed , newValue) {
//     this.model = model;
//     this.producer = producer;
//     this.age = age;
//     this.speed = speed;
//     this.engine = engine;
//     this.newSpeed =newSpeed;
//     this.newValue =newValue;
//
//     this.drive = function () {
//         console.log(`Їдемо зі швидкістю ${this.speed}`);
//     }
//     this.info = function () {
//         console.log(this);
//     }
//     this.newValue = function (Value){
//         this.age = Value;
//     }
//     this.newSpeed = function (Speed){
//         this.speed = Speed;
//     }
//     this.driver = function (N , A){
//         this.driver = {name:N , age:A };
//     }
//
// }
// let car = new F('Lada Kalina' , 'MAЗ' ,2017 , 187, '90sm^3' , 190 , 2019);
// console.log(car);
// car.drive();
//
// car.newValue(2019)
// car.newSpeed(200)
// car.driver( 'Ivan' ,23)
// car.info()
//5
// class Class {
//     constructor(model, producer, age , speed,  engine ) {
//         this.model = model;
//         this.producer = producer;
//         this.age = age;
//         this.speed = speed;
//         this.engine = engine;
//     }
//
//     info(){
//         console.log(this);
//     }
//     drive(){
//         console.log(`Їдемо зі швидкістю ${this.speed}`);
//     }
//     newValue  (Value){
//         this.age = Value;
//     }
//     newSpeed  (Speed){
//         this.speed = Speed;
//     }
//     driver(N , A){
//         this.driver = {name: N, age:A };
//     }
// }
// let car = new Class('Lada Kalina' , 'MAЗ' ,2017 , 187, '90sm^3');
// console.log(car);
// car.drive();
//
// car.newValue(2019)
// car.newSpeed(200)
// car.driver('Ivan' ,23)
// car.info()

// 6
// class Cinderella{
//     constructor(name , age ,size) {
//         this.name=name;
//         this.age=age;
//         this.size=size;
//     }
// }
// let Elizaveta = new Cinderella('Elizaveta',28 ,39);
// let Ira = new Cinderella('Ira',24 ,40);
// let Miroslava = new Cinderella('Miroslava',17 ,38);
// let Bronislava = new Cinderella('Bronislava',21 ,43);
// let Lyudmila = new Cinderella('Lyudmila',19 ,39);
// let Elvina = new Cinderella('Elvina',27 ,36);
// let lyubov = new Cinderella('lyubov',18 ,37);
// let Marya = new Cinderella('Marya',30 ,40);
// let Olga = new Cinderella('Olga',23 ,41);
// let Angela = new Cinderella('Angela',18 ,37);
// let princess =[Elizaveta,Ira,Miroslava,Bronislava,Lyudmila,Elvina,lyubov,Marya,Olga,Angela];
// let prince ={name:'Ioan',age:17,HaveSize:38};
// for (let i = 0; i < princess.length; i++) {
//     const princessElement = princess[i];
//     if (prince.HaveSize === princessElement.size){
//         console.log(`Happy marriage princess ${princessElement.name} and prince ${prince.name} . And they lived happily ever after`)
//     }
//
// }

//7
// function Cinderella(name , age ,size){
//
//     this.name=name;
//     this.age=age;
//     this.size=size;
//
// }
// let Elizaveta = new Cinderella('Elizaveta',28 ,39);
// let Ira = new Cinderella('Ira',24 ,40);
// let Miroslava = new Cinderella('Miroslava',17 ,38);
// let Bronislava = new Cinderella('Bronislava',21 ,43);
// let Lyudmila = new Cinderella('Lyudmila',19 ,39);
// let Elvina = new Cinderella('Elvina',27 ,36);
// let lyubov = new Cinderella('lyubov',18 ,37);
// let Marya = new Cinderella('Marya',30 ,40);
// let Olga = new Cinderella('Olga',23 ,41);
// let Angela = new Cinderella('Angela',18 ,37);
// let princess =[Elizaveta,Ira,Miroslava,Bronislava,Lyudmila,Elvina,lyubov,Marya,Olga,Angela];
// let prince ={name:'Ioan',age:17,HaveSize:38};
// function FindingThePrincess() {
//     for (let i = 0; i < princess.length; i++) {
//         const princessElement = princess[i];
//         if (prince.HaveSize === princessElement.size){
//             console.log(`Happy marriage princess ${princessElement.name} and prince ${prince.name} . And they lived happily ever after`)
//         }
//
//     }
// }
// FindingThePrincess()


